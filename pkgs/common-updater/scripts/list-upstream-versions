#!/usr/bin/env bash
set -e

####################################################################################################
# Helper functions
####################################################################################################

warn() {
    echo "$0: warning: $1" >&2
}

die() {
    echo "$0: error: $1" >&2
    exit 1
}

# Eval a Nix expression, with the un-escaped output going to stdout.
evalNix() {
    nix-instantiate --eval --strict --json "$@" | jq -r '. | tostring'
}

# Get version of a package
getVersion() {
    evalNix -E "with import ./. {}; $1.version or (builtins.parseDrvName $1.name).version"
}

# Figure out the pattern from a git tag or a filename:
#    guessVersionPattern "fio-2.12" "2.12" -> "fio-([0-9].*)"
#    guessVersionPattern "read-edid-3.0.2.tar.gz" "3.0.2" -> "read-edid-([0-9].*)\.tar\.gz"
guessVersionPattern() {
    # '.' and '+' should be the only things that needs escaping, as Nix refuses derivations with funny 'name' attributes
    local escapedVersion=$(echo "$2" | sed -re 's/[.+]/\\&/g')
    local ret=$(echo "$1" | sed -re "s|$escapedVersion|@|; s|[.+]|\\\\&|g; s|@|([0-9].*)|")
    if [ "$ret" = "$1" ]; then
        die "guessVersionPattern(): couldn't figure out version pattern from tag/filename '$1' and version '$2'"
    fi
    echo "$ret"
}

listLinksInUrl() {
    local url="$1"

    if [[ $url =~ ^ftp:// ]]; then
        # For a FTP url, just do a file listing of the directory.
        curl -sSL "$downloadPage/" -l
    else
        # For HTTP, extract the links from the HTML and extract the filename part (in case there are absolute links).
        curl -sSL "$downloadPage" | xidel -q --extract "//a/@href" - | sed -e 's|^.*/||'
    fi
}

filterCommonPrereleaseVersions() {
    grep -v -P '(?<![a-zA-Z])(alpha|beta|rc|pre)(?![a-zA-Z])'
}

####################################################################################################
# Functions for listing available upstream versions
#
# Variables in scope at this point:
#  - attr: attribute path of the package to list versions for
#  - url: url of the src attribute of the package
#  - oldVersion: old version of the package in question
#
# The implementation should fetch the available upstream versions from the Internet
# and print them to stdout, one version number per line.
####################################################################################################
listVersionsGitTag() {
    local gitUrl="$1"
    rev=$(evalNix -A "$attr.src.rev" | sed -re 's|refs/tags/||')

    versionPattern=$(guessVersionPattern "$rev" "$oldVersion")

    git ls-remote -t --refs "$gitUrl" | sed -re 's|.*refs/tags/||' | grep -E "^$versionPattern$" | sed -re "s|$versionPattern|\1|"
}

listVersionsHttp() {
    # Resolve mirror:// URLs if needed
    # FIXME: quite ugly implementation
    if [[ $url =~ mirror://([^/]+)/(.*) ]]; then
        mirror="${BASH_REMATCH[1]}"
        rest="${BASH_REMATCH[2]}"
        base=$(evalNix ./pkgs/build-support/fetchurl/mirrors.nix -A "$mirror.0")
        url="$base$rest"
    fi

    # Make a guess for the download page: simply remove the filename part of the URL.
    # Often works for Apache directory listings, for example.
    local downloadPage="$(evalNix -E "with import ./. {}; $attr.meta.downloadPage or \"\"")"
    if [ -z "$downloadPage" ]; then
        downloadPage="${url%/*}"
    fi
    local fileName="${url##*/}"

    versionPattern=$(guessVersionPattern "$fileName" "$oldVersion")

    listLinksInUrl "$downloadPage" | grep -E "^$versionPattern$" | sed -re "s|$versionPattern|\1|"
}

listVersionsSourceforge() {
    local project="$1"
    local fileName="${url##*/}"

    versionPattern=$(guessVersionPattern "$fileName" "$oldVersion")

    # Try to look for uploaded artifacts from the SourceForge project's RSS.
    # Same approach that was used by monitor.nixos.org
    curl -sSL "https://sourceforge.net/projects/$project/rss" | xidel -q --extract '//rss/channel/item/link' - \
        | sed -re 's|.*/([^/]+)/download$|\1|' \
        | grep -E "^$versionPattern$" | sed -re "s|$versionPattern|\1|"
}
####################################################################################################
# Main code
####################################################################################################
# Usage: list-upstream-versions <attr>
attr=$1

url=$(evalNix -E "with import ./. {}; $attr.src.url or (builtins.head $attr.src.urls)")
if [ -z "$url" ]; then
    die "couldn't evaluate URL of the source attribute of '$attr'!"
fi

oldVersion=$(getVersion "$attr")

if [[ $url =~ mirror://sourceforge/([^/]+)/ ]]; then
    project="${BASH_REMATCH[1]}"

    lister="listVersionsSourceforge $project"
elif [[ $url =~ https?://github\.com/([^/]+)/([^/]+)/archive/(.*)\.(zip|tar\.gz|tar\.bz2|tar\.xz) ]]; then
    owner="${BASH_REMATCH[1]}"
    repo="${BASH_REMATCH[2]}"

   lister="listVersionsGitTag https://github.com/$owner/$repo.git"
# FIXME: hacky way of detecting fetchgit
elif [ "$(evalNix -E "with import ./. {}; builtins.hasAttr \"fetchSubmodules\" $attr.src")" = true ]; then
   lister="listVersionsGitTag $url"
else
   lister=listVersionsHttp
fi

readarray -t allVersions < <(eval "$lister" | sort -Vr | filterCommonPrereleaseVersions)
if [ "${#allVersions[@]}" = 0 ]; then
    die "Version lister didn't find any versions for '$attr'!"
fi

foundCurrent=
for ver in "${allVersions[@]}"; do
    echo "$ver"
    if [ "$ver" = "$oldVersion" ]; then
        foundCurrent=1
    fi
done
if [ -z "$foundCurrent" ]; then
    warn "Version lister didn't find the current version ($oldVersion) for '$attr'!"
fi

latestVersion="${allVersions[0]}"
if [ "$latestVersion" != "$oldVersion" ]; then
    echo "Update available for '$attr', from '$oldVersion' to '$latestVersion'!"
else
    exit 0
fi

if [ "$2" == "--commit" ]; then
    ./pkgs/common-updater/scripts/update-source-version "$attr" "$latestVersion"
    git commit -a -m "$attr: $oldVersion -> $latestVersion"
fi
